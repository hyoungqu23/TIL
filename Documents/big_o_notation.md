## 🧩 Getting Started

알고리즘 공부를 진행하면서 가장 많이 듣는 개념은 다름아닌 Big O Notation이다. 따라서 이를 정리하는 시간을 가져야 겠다고 생각했다. Big O Notation을 단순히 알고리즘을 평가하는 방법 중 하나라고 인지하고만 있었기에, 더 깊은 이해를 위해서는 명확한 개념을 이해하고 사용하는 것이 더 좋겠다는 판단을 내렸다.

사실 이번 팀 프로젝트를 진행하면서 사실 코드의 성능이나 클린 코드 등 평소 관심을 두고 있었던 부분을 전혀 신경쓰지 못했다. 프로젝트가 종료된 후 회고를 작성하며 그 원인에 대해 생각해봤다.

- 첫 번째 팀 프로젝트이고, 프로젝트 기간이 2주로 짧게 설정되어 기능 개발에 치중했다는 점.
- 빠르게 성능을 비교하고 더 나은 코드를 선택할 만한 기준과 경험이 부족했다는 점.
- 내가 작성한 깔끔한 코드가 반드시 좋은 성능을 가지지는 않는다는 점.
- 깔끔하고 가독성 좋은 코드가 반드시 짧은 코드를 의미하지 않는다는 것을 뒤늦게 깨달았다는 점.

따라서 부족한 경험과 기준에 대한 반발작용으로 알고리즘 공부를 시작했다. 물론, 면접, 과제 등에서도 활용할 수 있는 실전 지식이 될 수 있다면 좋겠다.

---

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ed2660c-9462-4f08-afdf-2f36caf4d091/Untitled.png)

## 🧩 Big O Notation

- **Slides**
  [Big O Notation](https://cs.slides.com/colt_steele/big-o-notation#/40/0/6)

**Big O Notation**은 여러가지 코드를 일반적으로 서로 비교하고 성능을 평가하는 방법이다.

하나의 문제를 해결하기 위해서 존재하는 여러 해결책이 있고, 우리는 항상 효율적으로 문제를 해결하고자하기 때문에 어떤 해결책이 가장 효율적이고 높은 성능을 가지고 있는지를 판단해야 한다. 이러한 판단 과정에는 기준이 필요한데, 코드의 성능을 판단하는 기준을 **Big O Notation**이 제시하고 있는 것이다. 또한, 해당 문제에 대한 해결책으로 내가 제시한 것과 다른 해결책들을 비교하고 어떤 것이 성능이 더 나은지 확인하기 위해서는 성능을 쉽게 파악할 수 있게 해주는 판별법이 필요하다.

다만, 더 나음의 기준이 무엇인가?

- 속도
- 메모리 사용량
- 코드량
- 기타 등등

보통의 사람들은 속도와 메모리 사용량이라고 대답한다. 뭐 다른 사람들은 코드량이라거나 아니면 다른 무엇인가의 기준을 가지고 대답할 수 있다.

- 내장 Timing Function: `performance.now();`

다만, 이렇게 시간 측정을 기반으로한 속도 측정에는 문제가 있다.

- 기기마다 다른 측정된 시간 문제
- 같은 기기더라도 매번 다른 측정 시간 문제
- 굉장히 빠른 알고리즘의 경우 시간을 정확히 측정하지 못하는 문제

### Example

> 숫자 n을 받아, 1부터 n까지의 합을 구하라.

```jsx
function add(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}
```

가장 쉽게 생각할 수 있는 해결책은 for Loop을 활용해 1부터 n까지 더하는 방법이다. 나 또한 이 방법을 문제를 보자마자 떠올릴 수 있었는데, 그 이유를 추측해보면 가장 단순한 방법이기 때문이라고 생각된다. 즉, 1부터 숫자를 1씩 증가시키면서 더해주면 결국 1부터 n까지 모두 더하게 되는 것이다.

- 연산의 개수는 sum의 덧셈이 n번만큼 진행되고, 할당이 n번 진행되는 것과 동시에, i의 덧셈과 할당이 진행되기 때문에, 4n개에 추가로, sum과 i의 초기값 할당과 i와 n의 비교가 n번 진행되므로, `5n+2`개의 연산이 존재한다.

```jsx
function add(n) {
  return (n * (n + 1)) / 2;
}
```

물론 짧은 코드가 무조건 더 성능이 뛰어나다고 말할 수는 없지만, 이번 문제에서는 허용되는 말이다. 수학적 공식을 활용해 더 쉽게 해결책을 가져올 수 있다. 여기서 우리에게는 $n(n+1) / 2$ 은 이미 증명된 수학 공식으로 어떻게 만드는 지가 중요하지 않다.

- 연산의 개수는 `3`가지로, 곱셈, 덧셈, 나눗셈으로 구성된다.

따라서 우리는 시간이 아니라, 컴퓨터가 처리해야 하는 연산의 갯수를 가지고 해당 코드의 성능을 파악할 수 있다. 이러한 방법은 기기에 따른 차이가 존재하지 않고, 매번 달라지지도 않는다. 즉, 한 알고리즘은 연산을 5번 해야하고, 다른 알고리즘은 7번 해야 한다면, 시간의 차이는 존재하겠지만, 항상 연산의 갯수에 따라 시간이 소요될 것이다.

**다만, 연산 개수의 정확한 숫자는 상관없고, 전체적인 추세를 확인하는 것이 중요하다. 위 예제에서 `5n+2`는 `n`이 커질수록 연산의 개수도 비례적으로 늘어난다는 추세가 중요한 점이고, `3`은 일정하게 유지되는 상수라는 점이 중요한 것이다.**

Big O는 대략적으로 숫자를 세는 것에 붙인 공식적인 표현으로, 입력되는 내용이 늘어날수록 알고리즘의 실행시간이 어떻게 변하는지를 설명하는 방식이다. 즉, 알고리즘의 `input Size`이 늘어나는 것과 해당 알고리즘의 `실행 시간` 사이의 관계를 의미한다. 기본적으로 `input`인 $n$이 커질수록, 해당 알고리즘이 얼마나 효율적인지를 표현하는 것이다.

> $n$이 커질수록 컴퓨터가 $constant × f(n)$보다 단순 연산을 덜 한다면 그 알고리즘을 $O(f(n))$이라고 표현한다.

- $f(n) = n$ 이면, `**Linear**`
- $f(n) = n^2$ 이면, `**Quadratic**`
- $f(n) = 1$ 이면, `**Constant**`
- 등등

따라서 위 예제의 1번째 함수의 Big O는 $n$의 곱인 $O(n)$이 된다. $1n$, $5n$, $10n$인지는 상관이 없다. 결국 궁극적으로 그래프가 직선적인 형태를 띄는 것은 동일하기 때문이다. 이와 달리 위 예제의 2번째 함수의 Big O는 $O(1)$이 된다. 즉, $n$의 값이 커지더라도 실행 시간은 변하지 않는다.

```jsx
function countUpAndDown(n) {
  // O(n)
  for (var i = 0; i < n; i++) {
    console.log(i);
  }

  // O(n)
  for (var j = n - 1; j >= 0; j--) {
    console.log(j);
  }
}
```

따라서 `**countUpAndDown()**` 함수의 Big O는 $O(n)$ + $O(n)$으로 $O(2n)$이 아니라 단순히 $O(n)$이 된다.

```jsx
function printAllPairs(n) {
  // O(n)
  for (var i = 0; i < n; i++) {
    // O(n)
    for (var j = 0; j < n; j++) {
      console.log(i, j);
    }
  }
}
```

중첩 for Loop을 가진 **`printAllPairs()`** 함수의 Big O는 $O(n^2)$이다. 즉, $n$이 커질수록 실행 시간이 $n^2$만큼 늘어난다는 것이다.

### Big O 단순화 규칙

- **모든 상수는 무시한다.**
  무한까지 확장하면, 그래프 상에서 상수는 영향력이 없다.
  $O(500)$ → $O(1)$
  $O(200000n)$ → $O(n)$
  $O(1000n^2)$ → $O(n^2)$
- **작은 연산도 무시한다.**
  $O(500n + 3000)$ → $O(n)$
  $O(n + 100000)$ → $O(n)$
  $O(n^2 + 50000n + 800000)$ → $O(n^2)$
  ↳ 궁극적으로 $n^2$에 비해 $50000n + 800000$은 아무런 의미가 없는 연산이 된다.
- **사칙 연산**은 단순 상수에 해당한다.
- **변수 할당** 또한 단순 상수에 해당한다.
- 배열의 **index를 통해 배열 요소에 접근**하는 것이나 객체의 **key를 통해 접근**하는 것은 단순 상수에 해당한다.
  index를 통해 첫 번째 아이템을 찾는 것과 10번째 아이템을 찾는 것은 동일한 실행 시간이 소요된다. 객체의 key를 통해 value를 찾는 것도 동일하다.
- loop가 있다면, **loop의 길이와 loop 내부의 연산의 개수의 곱**이 Big O가 된다.

## 🧩 Space Complexity

input Size가 커질수록 알고리즘이 얼마나 많은 공간을 차지하는 지. 즉, 얼마나 많은 메모리를 사용하는지를 파악하는 척도이다.

여기서 이야기하는 공간 복잡도는 사실 보조 공간 복잡도(Auxiliary Space Complexity)를 의미한다. 보조 공간 복잡도는 input을 제외하고 알고리즘 자체가 필요로 하는 공간이 얼마인지를 나타낸다. 입력의 크기는 무한대로 늘어나기 때문에, 이를 제외한 알고리즘의 크기를 파악하는 것이 유의미하기 때문이다.

- **원시 자료형(boolean, numbers, undefined, null)**은 불변 공간을 차지한다.
- **문자열의 길이가 $n$인 문자열**은 $O(n)$의 공간 복잡도를 가진다.
- **배열의 길이가 $n$인 배열**과 **객체의 key의 개수가 $n$인 객체**는 $O(n)$의 공간 복잡도를 가진다.

## 🧩 Big O with Arrays and Objects

- **Slides**
  [https://cs.slides.com/colt_steele/built-in-data-structures-25#/3](https://cs.slides.com/colt_steele/built-in-data-structures-25#/3)

### Objects

`key: value` 쌍으로 이루어진 정렬되지 않은 데이터 구조.

- 정렬하지 않아도 된다.
- 새로운 객체를 어디에 입력하든지 상관없다.
- 객체에는 시작과 끝이 없다.
- 빠른 접근, 삽입, 제거가 가능하다.
  - 삽입, 제거, 수정, 접근 → $O(1)$
  - 검색 → $O(n)$

JavaScript는 어떤 정보를 객체 안에 저장할 때 상수 시간이 걸리며, 원하는 내용을 상수 시간 안에 불러오거나, 수정하거나, 삭제할 수도 있다.

어떤 특정한 정보가 어떤 값에 있는 지 확인하기 위한 행동인 **검색**은 잠재적으로 모든 아이템의 모든 속성을 찾아봐야 한다. 따라서 선형 시간 복잡도($O(n)$)를 갖게 된다.

**Object 메서드의 Big O**

- `Object.keys` → $O(n)$ : 모든 아이템의 `key` 값을 배열에 추가해야 하기 때문에 선형 시간 복잡도.
- `Object.values` → $O(n)$ : 모든 아이템의 `value` 값을 배열에 추가해야 하기 때문에 선형 시간 복잡도.
- `Object.entries` → $O(n)$ : 모든 아이템의 `key`, `value` 값을 배열에 추가해야 하기 때문에 선형 시간 복잡도.
- `hasOwnProperty` → $O(1)$ : 해당 속성이 있는지 여부를 boolean으로 반환하기 때문에 객체 접근과 동일한 상수 시간 복잡도.

### Arrays

- 정렬되어 있어 유용할 수 있으나, 연산에 시간이 더 소요될 수 있다.
- 정렬이 필요하지 않은 데이터는 성능 최적화를 위해 다른 데이터 구조를 활용하는 것이 좋다.
- 배열에 접근하는 것은 쉽다. index라는 해당 데이터로 향하는 지름길이 있기 때문이다.
  - 접근 → $O(1)$
  - 검색 → $O(n)$ … 최적화 가능성 존재
  - 삽입, 제거
    - 배열 끝에 삽입 혹은 제거하면, $O(1)$
    - 배열 앞에 삽입 혹은 제거하면, 모든 요소의 index를 변경해야 하기 때문에, $O(n)$
    - 즉, `push`와 `pop`이 `shift`와 `unshift`보다 빠르다.(빈 배열의 경우 제외)

**Array 메서드의 Big O**

- `push()` → $O(1)$
- `pop()` → $O(1)$
- `shift()` → $O(n)$ : 배열의 모든 요소의 index를 수정해야 하기 때문에 선형 시간 복잡도.
- `unshift()` → $O(n)$ : 배열의 모든 요소의 index를 수정해야 하기 때문에 선형 시간 복잡도.
- `concat()` → $O(n)$ : 덧붙일 배열의 요소를 뒤에 추가하는 것과 같으므로 선형 시간 복잡도.
- `slice()` → $O(n)$ : 배열의 특정 부분을 잘라 가져오기 때문에 선형 시간 복잡도.
- `splice()` → $O(n)$ : 배열의 특정 index 요소를 제거하고 새로운 요소를 삽입하면, 최소로 상수 시간 복잡도를 가질 수 있으나, 최악의 경우 첫 요소를 제거하고 삽입하여 선형 시간 복잡도를 가질 수 있으므로 선형 시간 복잡도.
- `sort()` → $O(nlogn)$ : 여러 정렬 알고리즘이 가지는 시간 복잡도. 비교하고 이동하는 것을 반복하기 때문이다.
- `forEach()`, `map()`, `filter()`, `reduce()` → $O(n)$ : 배열의 모든 요소에 작업을 실행하기 때문에 선형 시간 복잡도.
