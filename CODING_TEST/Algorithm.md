# 🔎 Algorithm & Data Structure
## 📌 Algorithm
- 어떠한 동작을 수행하기 위해 컴퓨터가 수행해야 하는 여러 가지의 지시사항.
- 효율적인 알고리즘을 찾는다면, 반복하여 활용할 수 있다.(암호화 알고리즘, 길 찾기 알고리즘, 이미지 압축 알고리즘 등)
- 데이터 구조와 마찬가지로 알고리즘 선택에 따라 해당 작업을 수행하는 속도의 차이가 나기 때문에 상황에 따라 적절한 알고리즘을 선택하는 것이 중요하다.

## 📌 Data Structure
- 어떻게 데이터를 정리할 것인지에 대한 것.
- 데이터를 정리하는 방법에 따라 속도에 영향을 미치기 때문이다.
- 정렬, 추가, 검색, 편집 등에 강한 데이터 구조가 각각 다르다.
- 4가지 상황(검색(Search), 읽기(Read), 삽입(Insert), 삭제(Delete))에 적합한 데이터 구조를 사용해야 한다.

## 📌 Time Complexity
데이터 구조의 알고리즘의 속도를 측정하는 방법으로, 얼마나 적은 시간이 걸리는 지를 측정하는 것이 아니라, 얼마나 적은 단계를 거치는 지를 측정하는 것이다. 시간은 하드웨어의 성능에 따라 달라질 수 있기 때문이다.

### Big O 표기법
시간복잡도를 표기하는 방법 중 하나로, 알고리즘 분석을 빠르게 할 수 있고, 언제 어떤 알고리즘을 활용할 지에 대해 알 수 있다. 또한, 코드를 더 적절하게 리뷰할 수 있다.
Big O 표기법은 투입된 데이터의 길이에 관계 없이 어떻게 이 함수가 작동하는 지에 따라 결정된다. 상수에 신경쓰지 않는다. 즉, 투입된 데이터의 길이에 상관없이 반드시 항상 1000개의 단계를 필요로하는 알고리즘의 시간복잡도는 $$O(1000)$$가 아니라 $$O(1)$$이 된다.
```javascript
// O(1)
function print(arr) {
  console.log(arr[0]);
}
```
```javascript
// O(1)
function print(arr) {
  console.log(arr[0]);
  console.log(arr[0]);
  console.log(arr[0]);
  console.log(arr[0]);
}
```
다만, 이러한 알고리즘만 있는 것은 아니고, 배열의 길이에 따라 단계의 수가 달라지는 것도 있다. 이러한 경우는 선형 검색 알고리즘과 유사하게 100개의 요소를 가진 배열의 경우 100개의 단계가 필요하고, 배열이 1000개의 요소를 가졌다면, 1000개의 단계가 필요하다. 즉, 배열이 커질수록 필요한 단계의 수도 증가한다.
```javascript
// O(N)
function print_all(arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
}
```
```javascript
// O(N)
function print_all(arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
}
```
배열의 각 요소에 대해 중첩적인 반복문이 있는 경우에 2차 시간(Quadratic Time)을 시간복잡도로 갖게 된다. 또한, 정렬된 배열에서 사용하는 이진 검색 알고리즘과 같은 로그 시간(Logarithmic Time)을 시간복잡도로 갖는 알고리즘도 존재한다. 
```javascript
// O(N^2)
function print_all(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length; j++) {
      console.log(arr[i], [j]);
    }
  }
}
```

## 📌 Memory
`RAM`과 같은 휘발성 메모리와 `HDD` 등의 비휘발성 메모리가 존재한다. 프로그램에서 설정한 변수 등은 `RAM`에 저장되는데 `RAM`은 Random Access Memory로 주소만 알고 있다면 언제든 접근할 수 있다.

## 📌 Data Structure 001. Array
Array의 경우 JavaScript, Python을 제외한 프로그래밍 언어에서는 반드시 Array의 길이를 먼저 설정해야 한다.

### Operation 1. Reading
- Array는 주소, 즉 `index`만 알고 있으면 필요한 `value`을 찾을 수 있다. 이때, `index`는 `0`부터 시작하는 점에 유의해야 한다.
- 컴퓨터는 Array가 어디서부터 시작하는지 알고 있기 때문에, 데이터를 빠르고 많이 읽어낼 수 있다. 즉, 요소가 5개 있는 Array와 1000개 있는 Array 모두 데이터를 읽는 단계는 동일하다.
  
### Operation 2. Searching
- 데이터를 검색하는 것은 필요한 데이터의 `index`를 알지 못하고, 특정 주소에 있는 값이 원하는 데이터인지도 알 수 없기 때문에 Array의 처음부터 순차적으로 하나씩 확인해야 한다.(Linear Search, 선형 검색)

### Operation 3. Insert(Add)
- Array의 길이가 이미 설정되어 있기 때문에 해당 길이를 초과하는 삽입의 경우 새로운 길이의 Array 만들고, 기존 Array를 복사한 후 삽입해야 하기 때문에 여러 단계를 거쳐야 한다.
- 이와 달리 기존 Array에 빈 공간이 있는 경우에는 마지막에 삽입하는 경우가 가장 적은 단계를 거치고, 처음에 삽입하는 경우 뒤의 모든 요소들을 하나씩 밀어내야 하기 때문에 조금 많은 단계를 거치게  된다.

### Operation 4. Delete
- Array의 삽입과 동일하게 마지막 요소를 삭제하는 경우는 적은 단계를 거치지만, 첫 번째 요소를 삭제하는 경우에는 삭제 후 모든 요소를 하나씩 당겨야 하기 때문에 조금 많은 단계를 거치게 된다.

## 📌 Algorithm 001. Linear Search, Binary Search
### Linear Search(선형 검색 알고리즘)
검색을 하기 위한 가장 자연스러운 알고리즘.
가장 첫 번째 요소부터 검색 대상과 일치하는 지 여부를 하나씩 순서대로 확인한다. 다만, 검색 대상이 배열의 마지막 요소이거나, 배열에 없는 경우 모든 요소를 확인해야 하고, 배열이 길어질수록 검색 시간이 오래 걸린다(Linear Time Complexity, 선형 시간 복잡도)는 점이 문제가 된다.
$$O(N)$$

### Binary Search(이진 검색 알고리즘)
이진 검색 알고리즘은 정렬된 배열(Sorted Array)에서만 사용할 수 있다.
정렬된 배열에서 요소를 추가하는 것은 정렬되지 않은 배열에 추가하는 것보다 오랜 시간이 소요된다. 즉, 정렬된 배열에서는 첫 번째 요소부터 확인하여 추가할 값보다 큰 값을 비교를 통해 검색한 후 해당 요소의 왼쪽에 삽입해야 하기 때문에 더 많은 시간이 소요된다.
다만, 검색의 경우 정렬된 배열에서 이진 검색 알고리즘을 활용하면 훨씬 빠르다. 이진 검색은 정렬된 배열의 정중앙의 요소에서 시작한다. 해당 요소의 값과 검색할 값을 비교하여 검색할 값이 큰 경우 오른쪽 절반의 배열에 이진 검색을 다시 적용하고, 작은 경우 왼쪽 절반의 배열에 이진 검색을 적용한다. 이러한 프로세스를 반복한다.
이러한 이진 검색의 경우 배열이 2배 길어져도 1번의 단계만 추가되기 때문에 큰 사이즈의 데이터를 효율적으로 처리할 수 있게 된다. 예를 들어 10000개의 요소를 가진 배열을 선형 검색을 하는 경우 최대 10000단계가 필요하지만, 이진 검색을 하는 경우 최대 14단계만이 필요하다.
따라서 검색을 많이 하는 경우 배열을 정렬하는 것이 좋지만, 요소를 추가할 때는 오래 걸리게 된다.
$$O(logN)$$

## 📌 Algorithm 002. Sort
### Bubble Sort(버블 정렬)
배열의 첫 두 요소를 선택하고, 비교한 후 더 큰 값을 가진 요소를 오른쪽에 둔다. 이후 해당 요소와 다시 그 오른쪽 요소를 선택하여 비교하고 반복한다. 마지막 요소까지 진행된 후에는 다시 첫 두 요소로 돌아가 해당 과정을 반복한다.
버블 정렬의 경우, 하나의 사이클마다 N-1, N-2, N-3, N-4 ... 회 비교를 실행하고, 모든 요소를 옮겨야 하는 상황이 있을 수 있다. 이때 버블 정렬의 시간복잡도는 2차 시간을 갖는다.
$$O(N^2)$$

### Selection Sort(선택 정렬)
전체 요소 중 가장 작은 값을 가진 요소의 위치값(Index)를 변수에 저장하고, 해당 요소를 배열의 첫 번째 요소와 맞바꾼다. 이후 두 번째 요소부터 가장 작은 값을 찾아 위치값을 변수에 저장하고, 해당 요소를 배열의 두 번째 요소와 맞바꾼다. 이를 반복하면 정렬할 수 있다.
선택 정렬의 경우 하나의 사이클마다 N-1, N-2, N-3, N-4 ... 회 비교를 실행하는 점은 버블 정렬과 동일하나, 하나의 사이클마다 1회만 맞바꾸는 상황이 존재한다. 하지만 여전히 선택 정렬의 시간복잡도는 2차 시간을 갖는다.
$$O(N^2)$$

### Insertion Sort(삽입 정렬)
전체 요소 중 두 번째 요소부터 비교를 시작한다. 선택한 요소의 왼쪽의 요소 중 선택한 요소의 값보다 큰 경우 모두 맞바꾸는 작업을 진행한다. 이후 다음 순번의 요소부터 반복한다. 여전히 선택 정렬의 시간복잡도는 2차 시간을 갖는다. 다만 최선의 경우 $$O(N)$$의 시간복잡도를 갖게 된다.
$$O(N^2)$$

